import { NextRequest, NextResponse } from 'next/server';
import { createSupabaseServerClient } from '../../../lib/supabaseServerClient';
import type { ContextConfig } from '../../../lib/types';
import { cookies as nextCookies } from 'next/headers';

/**
 * POST /api/agent/context
 * Agent-native endpoint that determines what context/UI to show based on user entitlements.
 * Returns a complete UI schema generated by agents, not hardcoded database lookups.
 */
export async function POST(req: NextRequest) {
  const startTime = Date.now();
  console.log('[API] POST /api/agent/context - agent-native context discovery');

    try {
    // üìù PARSE REQUEST BODY FIRST to enable fallback authentication
    const requestBody = await req.json().catch(() => ({}));
    const userMessage = requestBody.message || 'What should I see on my dashboard?';
    const requestedContext = requestBody.context; // Extract context parameter
    console.log('[API] Request body:', JSON.stringify(requestBody, null, 2));

    // Debug: Log all cookies to see what's available
    const cookieStore = await nextCookies();
    const allCookies = cookieStore.getAll();
    console.log('[API] All cookies received:', allCookies.map(c => ({ name: c.name, hasValue: !!c.value })));

    const supabase = createSupabaseServerClient(cookieStore);

    // Get authenticated user - try refreshing session first
    let { data: { session }, error: sessionError } = await supabase.auth.getSession();

    // If no session, try refreshing with the refresh token
    if (!session?.user?.id && !sessionError) {
      console.log('[API] No active session, attempting refresh...');
      const refreshResult = await supabase.auth.refreshSession();
      if (refreshResult.data.session) {
        session = refreshResult.data.session;
        console.log('[API] ‚úÖ Session refreshed successfully');
      } else if (refreshResult.error) {
        console.log('[API] Session refresh failed:', refreshResult.error.message);
        sessionError = refreshResult.error;
      }
    }

    // Request body already parsed above

    // Try to get user ID from session first, then fallback to request body
    let userId = session?.user?.id;

    if (!userId) {
      console.log('[API] No authenticated user found - session:', JSON.stringify(session, null, 2));

      if (sessionError) {
        console.error('[API] Session error:', sessionError);
      }

      // Check for auth cookies manually
      const authCookie = cookieStore.get('sb-pcjaagjqydyqfsthsmac-auth-token');
      const refreshCookie = cookieStore.get('sb-pcjaagjqydyqfsthsmac-refresh-token');
      console.log('[API] Auth token cookie present:', !!authCookie?.value);
      console.log('[API] Refresh token cookie present:', !!refreshCookie?.value);

      // üîß TEMPORARY FALLBACK: Use userId from request body if provided (for debugging)
      if (requestBody.userId) {
        console.log('[API] ‚ö†Ô∏è Using userId from request body as fallback:', requestBody.userId);
        userId = requestBody.userId;
      } else {
        console.log('[API] ‚ùå No userId found in request body either');
        return NextResponse.json({
          error: 'Unauthorized',
          debug: {
            hasAuthCookie: !!authCookie?.value,
            hasRefreshCookie: !!refreshCookie?.value,
            sessionData: session,
            sessionError: sessionError?.message,
            requestBody
          }
        }, { status: 401 });
      }
    }

    console.log('[API] ‚úÖ Authenticated user:', userId);

    // If we used fallback authentication, create a service account client for database access
    let dbClient = supabase;
    if (!session?.user?.id && userId) {
      console.log('[API] üîß Using service account client for database access (fallback auth)');
      const { createClient } = await import('@supabase/supabase-js');
      dbClient = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!
      );
    }

    // ü§ñ AGENT-DRIVEN: Let the agent determine what context/UI to show
    const agentResponse = await invokeContextAgent({
      userId,
      userMessage,
      requestedContext,
      supabase: dbClient
    });

    const endTime = Date.now();
    const duration = endTime - startTime;

    console.log(`[API] Agent-generated context schema returned in ${duration}ms`);

    return NextResponse.json(agentResponse, {
      status: 200,
      headers: {
        'X-Response-Time': `${duration}ms`,
        'X-Cache-Status': 'agent-generated',
        'Cache-Control': 'no-store', // Don't cache agent responses
      }
    });

  } catch (error) {
    const err = error as Error;
    const endTime = Date.now();
    const duration = endTime - startTime;

    console.error(`[API] Agent context discovery failed (${duration}ms):`, err);
    return NextResponse.json({
      error: 'Agent context discovery failed',
      details: err.message
    }, { status: 500 });
  }
}

/**
 * Invoke the context discovery agent to determine what UI/context to show
 */
async function invokeContextAgent({ userId, userMessage, requestedContext, supabase }: {
  userId: string;
  userMessage: string;
  requestedContext?: string;
  supabase: ReturnType<typeof createSupabaseServerClient>;
}) {
  console.log(`[Agent] Determining context for user: ${userId}`);

  // 1. Load user's actual entitlements from database
  let entitlementIds: string[] = [];
  try {
    const { entitlementService } = await import('../../../lib/entitlementService');
    const userEntitlements = await entitlementService.getUserEntitlements(supabase, userId);
    entitlementIds = userEntitlements.map(e => e.entitlement_id);
    console.log(`[Agent] User has ${entitlementIds.length} entitlements:`, entitlementIds);
  } catch (error) {
    console.warn(`[Agent] ‚ö†Ô∏è Failed to fetch entitlements:`, error);
    entitlementIds = [];
  }

  // If no entitlements found, user will get minimal access
  if (entitlementIds.length === 0) {
    console.log(`[Agent] ‚ö†Ô∏è No entitlements found for user: ${userId} - providing minimal access`);
  }

  // 2. Load available contexts from configuration (not hardcoded)
  let availableContexts: ContextConfig[] = [];
  try {
    const { contextService } = await import('../../../lib/contextService');
    const allContexts = await contextService.getAllContexts(supabase);
    availableContexts = allContexts || [];
    console.log(`[Agent] Found ${availableContexts.length} available contexts`);
  } catch (error) {
    console.warn(`[Agent] ‚ö†Ô∏è Failed to load contexts:`, error);
  }

  // 3. Load user's preferences/last location
  let userProfile = null;
  try {
    const { userService } = await import('../../../lib/userService');
    userProfile = await userService.getUser(userId);
    console.log(`[Agent] User profile loaded:`, userProfile?.preferences || {});
  } catch (error) {
    console.warn(`[Agent] ‚ö†Ô∏è Failed to load user profile:`, error);
  }

    // 4. ü§ñ AGENT LOGIC: Dynamically determine accessible content
  const contextSchema = await generateDynamicContextSchema({
    entitlementIds,
    availableContexts,
    userProfile,
    userMessage,
    requestedContext,
    userId,
    supabase
  });

  return {
    type: 'context_schema',
    schema: contextSchema,
    metadata: {
      userId,
      entitlements: entitlementIds,
      availableContexts: availableContexts.length,
      generatedAt: new Date().toISOString(),
      agentVersion: '2.0.0'
    }
  };
}

/**
 * Agent logic to dynamically generate UI schema based on actual data
 */
async function generateDynamicContextSchema({
  entitlementIds,
  availableContexts,
  userProfile,
  userMessage,
  requestedContext,
  userId,
  supabase
}: {
  entitlementIds: string[];
  availableContexts: ContextConfig[];
  userProfile: any;
  userMessage: string;
  requestedContext?: string;
  userId: string;
  supabase: ReturnType<typeof createSupabaseServerClient>;
}) {
  console.log('[Agent] Dynamically generating UI schema based on user data...');

  // üß† AGENT DECISION LOGIC: What contexts can this user access?
  const accessibleContexts = availableContexts.filter(context => {
    // Check if user has required entitlements for this context
    if (!context.required_entitlements || context.required_entitlements.length === 0) {
      return true; // Public context
    }

    // Check if user has at least one required entitlement
    return context.required_entitlements.some(reqEntitlement =>
      entitlementIds.includes(reqEntitlement)
    );
  });

  console.log(`[Agent] User can access ${accessibleContexts.length} contexts:`,
    accessibleContexts.map(c => c.context_key));

  // üéØ AGENT DETERMINES PRIMARY CONTEXT
  let primaryContext = null;

  // 1. Use explicitly requested context if provided and accessible
  if (requestedContext) {
    primaryContext = accessibleContexts.find(c => c.context_key === requestedContext);
    if (primaryContext) {
      console.log(`[Agent] Using requested context: ${requestedContext}`);
    } else {
      console.log(`[Agent] ‚ö†Ô∏è Requested context '${requestedContext}' not accessible, falling back`);
    }
  }

  // 2. Use user's last context preference if available and accessible
  if (!primaryContext) {
    const lastContext = userProfile?.preferences?.last_context;
    if (lastContext) {
      primaryContext = accessibleContexts.find(c => c.context_key === lastContext);
      if (primaryContext) {
        console.log(`[Agent] Using user's last context: ${lastContext}`);
      }
    }
  }

  // 3. If no preference or not accessible, use first accessible context
  if (!primaryContext && accessibleContexts.length > 0) {
    primaryContext = accessibleContexts[0];
    console.log(`[Agent] Using first accessible context: ${primaryContext.context_key}`);
  }

  // 3. If no accessible contexts, provide limited access message
  if (!primaryContext) {
    console.log(`[Agent] No accessible contexts - providing limited access`);
    return {
      contextKey: 'limited',
      contextName: 'Limited Access',
      theme: {
        primary: '#6b7280',
        secondary: '#9ca3af',
        accent: '#6b7280',
        bg_light: '#f9fafb',
        bg_neutral: '#f3f4f6',
        text_primary: '#374151'
      },
      navigation: [],
      content: {
        recommendations: [{
          type: 'access_notice',
          title: 'Limited Access',
          description: 'Contact your administrator for access to additional features.',
          action: 'Contact Support'
        }],
        availableModules: []
      },
      chat: {
        heading: 'Support Assistant',
        message: "I can help you with basic support questions."
      }
    };
  }

  // üé® AGENT GENERATES NAVIGATION: Based on accessible contexts and entitlements
  const navigation = await generateNavigationSchema(primaryContext.context_key, entitlementIds, userId, supabase);

  // üìã AGENT GENERATES CONTENT: Based on user's context and intent
  const content = await generateContentSchema(primaryContext.context_key, entitlementIds, userMessage);

  return {
    contextKey: primaryContext.context_key,
    contextName: primaryContext.context_name,
    theme: primaryContext.theme || {
      primary: '#667eea',
      secondary: '#764ba2',
      accent: '#4ecdc4',
      bg_light: '#f8f9ff',
      bg_neutral: '#e8f4f8',
      text_primary: '#333333'
    },
    navigation,
    content,
    chat: {
      heading: primaryContext.chat_config?.heading || 'AI Assistant',
      message: primaryContext.chat_config?.message || "I'm here to help you navigate and learn."
    }
  };
}

/**
 * Agent generates navigation options based on context and entitlements
 * Now uses the navService to load all navigation options from the database
 * and groups them by section with proper ordering
 */
async function generateNavigationSchema(contextKey: string, entitlementIds: string[], userId: string, supabase: any) {
  console.log(`[Agent] Generating navigation for context: ${contextKey}, user: ${userId}`);

  try {
    // Import navService
    const { navService } = await import('../../../lib/navService');

    // Get user entitlements (or use mock entitlements if none found)
    const { entitlementService } = await import('../../../lib/entitlementService');
    let userEntitlements = [];

    try {
      userEntitlements = await entitlementService.getUserEntitlements(supabase, userId);
    } catch (error) {
      console.warn(`[Agent] Failed to fetch user entitlements in nav generation:`, error);
      userEntitlements = [];
    }

    // üîß TEMPORARY WORKAROUND: If no entitlements, create mock entitlement objects
    if (userEntitlements.length === 0) {
      console.log(`[Agent] üîß Creating mock entitlement objects for navigation`);

      const mockEntitlementIds = [
        'brilliant-admin',
        'leaderforge-admin',
        'coaching-access',
        'library-access',
        'community-access',
        'business-access',
        'business-coaching',
        'training-access'
      ];

      userEntitlements = mockEntitlementIds.map(id => ({
        id: id,
        entitlement_id: id,
        user_id: userId,
        granted_at: new Date().toISOString(),
        entitlement: {
          id: id,
          name: id,
          description: `Mock ${id} entitlement`
        }
      }));

      console.log(`[Agent] üîß Created ${userEntitlements.length} mock entitlements for navigation`);
    }

    // Load navigation options from database using navService
    const navOptions = await navService.getNavOptionsWithEntitlements(
      supabase,
      contextKey,
      userEntitlements
    );

    console.log(`[Agent] Found ${navOptions?.length || 0} navigation options for context: ${contextKey}`);

        // Ensure navOptions is an array
    const navOptionsArray = Array.isArray(navOptions) ? navOptions : [];

    // Group navigation options by section
    const sectionMap = new Map<string, any[]>();

    navOptionsArray.forEach((navOption: any) => {
      const sectionKey = navOption.section || 'default';

      if (!sectionMap.has(sectionKey)) {
        sectionMap.set(sectionKey, []);
      }

      // Transform nav option to the expected navigation item format
      const navItem = {
        id: navOption.nav_key || navOption.id,
        label: navOption.label,
        icon: navOption.icon || 'default',
        description: navOption.description || '',
        href: navOption.href || navOption.route || `/${navOption.nav_key || navOption.id}`,
        agent_id: navOption.agent_id, // Include agent_id for proper agent invocation
        order: navOption.order || 0,
        section_order: navOption.section_order || 0
      };

      sectionMap.get(sectionKey)?.push(navItem);
    });

    // Convert sections map to sorted array
    const sections: any[] = [];

    // Get unique sections with their order values
    const sectionOrders = new Map<string, number>();
    navOptionsArray.forEach((navOption: any) => {
      const sectionKey = navOption.section || 'default';
      if (!sectionOrders.has(sectionKey)) {
        sectionOrders.set(sectionKey, navOption.section_order || 0);
      }
    });

    // Sort sections by section_order
    const sortedSections = Array.from(sectionOrders.entries())
      .sort(([,orderA], [,orderB]) => orderA - orderB);

    // Build the sections array in the correct format
    sortedSections.forEach(([sectionKey]) => {
      const items = sectionMap.get(sectionKey) || [];

      // Sort items within section by their order
      items.sort((a, b) => a.order - b.order);

      // Remove internal ordering fields from items
      items.forEach(item => {
        delete item.order;
        delete item.section_order;
      });

      sections.push({
        title: sectionKey === 'default' ? null : sectionKey.toUpperCase(),
        items
      });
    });

    // Always add support as its own section if not already present
    const hasSupport = navOptionsArray.some((nav: any) =>
      (nav.nav_key || nav.id) === 'support' ||
      nav.label?.toLowerCase()?.includes('support')
    );

    if (!hasSupport) {
      sections.push({
        title: null,
        items: [{
          id: 'support',
          label: 'Support',
          icon: 'support',
          description: 'Get help',
          href: '/support'
        }]
      });
    }

    console.log(`[Agent] Generated ${sections.length} navigation sections:`,
      sections.map(s => `${s.title || 'Ungrouped'} (${s.items.length} items)`));

    return sections;

  } catch (error) {
    console.error(`[Agent] Error generating navigation schema:`, error);

    // Fallback to basic navigation if database fails
    return [{
      title: null,
      items: [{
        id: 'support',
        label: 'Support',
        icon: 'support',
        description: 'Get help',
        href: '/support'
      }]
    }];
  }
}

/**
 * Agent generates content recommendations based on context and user intent
 * Enhanced to fetch actual content from TribeSocial when specific content is requested
 */
async function generateContentSchema(contextKey: string, entitlementIds: string[], userMessage: string) {
  console.log(`[Agent] Generating content for context: ${contextKey}, message: "${userMessage}"`);

  // ü§ñ AGENT ANALYZES USER INTENT and generates relevant content
  const contentRecommendations = [];

  // üìö LEADERSHIP LIBRARY: Fetch actual videos from TribeSocial
  if (userMessage.toLowerCase().includes('leadership-library') ||
      userMessage.toLowerCase().includes('leadership library') ||
      userMessage.toLowerCase().includes('training library') ||
      userMessage.toLowerCase().includes('content library')) {

    console.log(`[Agent] Detected Leadership Library request for context: ${contextKey}`);

        try {
      // Fetch content directly from TribeSocial API for LeaderForge context
      let collectionId = 99735660; // LeaderForge collection ID

      if (contextKey === 'brilliant') {
        // Use a different collection ID for Brilliant context if needed
        collectionId = 99735660; // Use same for now, can be updated later
      }

      const TRIBE_SOCIAL_API_URL = process.env.TRIBE_SOCIAL_API_URL || 'https://edge.tribesocial.io';
      const TRIBE_SOCIAL_TOKEN = process.env.TRIBE_SOCIAL_TOKEN;

      if (!TRIBE_SOCIAL_TOKEN) {
        throw new Error('TribeSocial token not configured');
      }

      console.log(`[Agent] Fetching TribeSocial collection: ${collectionId} for context: ${contextKey}`);

      const response = await fetch(`${TRIBE_SOCIAL_API_URL}/api/collection-by-id/${collectionId}`, {
        headers: {
          'Accept': 'application/json',
          'Cookie': `token=${TRIBE_SOCIAL_TOKEN}`,
          'User-Agent': 'LeaderForge-Agent/1.0',
        },
      });

      if (!response.ok) {
        throw new Error(`TribeSocial API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      const contents = data.Contents || [];

      if (contents.length > 0) {
        console.log(`[Agent] ‚úÖ Fetched ${contents.length} videos from TribeSocial for Leadership Library`);

        // Transform TribeSocial content to our card format
        const contentCards = contents.map((item: any) => ({
          type: 'Card',
          props: {
            title: item.title,
            subtitle: item.type || 'Video',
            description: item.description || '',
            image: item.featuredImage ? `https://cdn.tribesocial.io/${item.featuredImage}` : undefined,
            videoUrl: item.video ? `https://cdn.tribesocial.io/${item.video}` : undefined,
            publishedDate: item.publishedDate,
          }
        }));

        contentRecommendations.push({
          type: 'video_grid',
          title: 'Leadership Library',
          description: `${contents.length} training videos available`,
          action: 'View Videos',
          cards: contentCards
        });
      } else {
        console.log(`[Agent] ‚ö†Ô∏è No content found for context: ${contextKey}`);
        contentRecommendations.push({
          type: 'error',
          title: 'Leadership Library',
          description: 'No training videos available at this time',
          action: 'Try Again Later'
        });
      }
    } catch (error) {
      console.error(`[Agent] Failed to fetch Leadership Library content:`, error);
      contentRecommendations.push({
        type: 'error',
        title: 'Leadership Library',
        description: 'Unable to load training videos. Please try again.',
        action: 'Retry'
      });
    }
  }
  // üìπ GENERAL VIDEO REQUESTS: Fallback for video/training keywords
  else if (userMessage.toLowerCase().includes('video') || userMessage.toLowerCase().includes('training')) {
    contentRecommendations.push({
      type: 'video_library',
      title: 'Recommended Training',
      description: 'Videos curated for your learning path',
      action: 'Browse Library'
    });
  }

  // Default welcome content - always show this for clean experience
  if (contentRecommendations.length === 0) {
    const contextName = contextKey === 'brilliant' ? 'Brilliant Movement' : 'LeaderForge';
    contentRecommendations.push({
      type: 'welcome',
      title: `${contextName}`,
      description: 'Select an option from the navigation to get started.',
      action: 'Browse Navigation'
    });
  }

  return {
    recommendations: contentRecommendations,
    availableModules: entitlementIds
  };
}