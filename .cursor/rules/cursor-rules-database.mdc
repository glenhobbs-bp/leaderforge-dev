---
description: 
globs: *.sql,*.tsx,*.json
alwaysApply: false
---
# LeaderForge Database Cursor Rules

## üèõÔ∏è Database Architecture Principles

### Core Rules
1. **Module data isolation** - Each module owns its tables
2. **Multi-tenant by default** - RLS on every table
3. **Event sourcing for conversations** - Append-only for agent interactions
4. **Audit everything** - Compliance and debugging
5. **Cache-friendly design** - Optimize for read patterns

## üìä Schema Organization

```sql
-- Schemas for organization
CREATE SCHEMA IF NOT EXISTS core;      -- Shared infrastructure
CREATE SCHEMA IF NOT EXISTS modules;   -- Module-specific tables
CREATE SCHEMA IF NOT EXISTS audit;     -- Audit and compliance
CREATE SCHEMA IF NOT EXISTS analytics; -- Analytics events

-- Module-specific schemas
CREATE SCHEMA IF NOT EXISTS modules_content;
CREATE SCHEMA IF NOT EXISTS modules_mlm;
CREATE SCHEMA IF NOT EXISTS modules_journal;
```

## üîë Core Tables

### Users & Authentication
```sql
-- Multi-context user support
CREATE TABLE core.users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  avatar_url TEXT,
  
  -- Multi-tenant support
  tenant_id UUID NOT NULL DEFAULT current_setting('app.tenant_id')::uuid,
  
  -- Module access
  enabled_modules TEXT[] DEFAULT ARRAY['movement'],
  current_module TEXT DEFAULT 'movement',
  
  -- Metadata
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ, -- Soft delete
  
  -- Indexes
  CONSTRAINT valid_current_module CHECK (current_module = ANY(enabled_modules))
);

CREATE INDEX idx_users_tenant ON core.users(tenant_id);
CREATE INDEX idx_users_email ON core.users(email);
CREATE INDEX idx_users_deleted ON core.users(deleted_at) WHERE deleted_at IS NULL;

-- RLS Policy
ALTER TABLE core.users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users see own tenant" ON core.users
  FOR ALL USING (
    tenant_id = current_setting('app.tenant_id')::uuid
    AND deleted_at IS NULL
  );
```

### Organizations & Entitlements System

#### Flexible Organization Hierarchy
```sql
-- Generic organization structure (company/team, church/small-group, etc.)
CREATE TABLE core.organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Flexible naming
  name TEXT NOT NULL,
  display_name TEXT NOT NULL,
  org_type TEXT NOT NULL, -- 'company', 'team', 'church', 'small_group', etc.
  
  -- Hierarchy
  parent_org_id UUID REFERENCES core.organizations(id),
  level INTEGER DEFAULT 0, -- 0=root, 1=sub-org, etc.
  path TEXT[], -- Array of org IDs from root to this org
  
  -- Module context
  module_id TEXT NOT NULL,
  
  -- Settings
  settings JSONB DEFAULT '{}', -- Per-org customization
  features JSONB DEFAULT '{}', -- Enabled features
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES core.users(id)
);

CREATE INDEX idx_org_parent ON core.organizations(parent_org_id);
CREATE INDEX idx_org_path ON core.organizations USING GIN(path);
CREATE INDEX idx_org_module ON core.organizations(module_id);

-- User organization membership
CREATE TABLE core.user_organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES core.users(id),
  org_id UUID NOT NULL REFERENCES core.organizations(id),
  
  -- Role within organization
  role TEXT NOT NULL CHECK (role IN ('owner', 'admin', 'member')),
  permissions JSONB DEFAULT '{}', -- Granular permissions
  
  -- Status
  status TEXT DEFAULT 'invited' CHECK (status IN ('invited', 'active', 'suspended')),
  
  -- Invitation flow
  invited_at TIMESTAMPTZ DEFAULT NOW(),
  invited_by UUID REFERENCES core.users(id),
  joined_at TIMESTAMPTZ,
  
  CONSTRAINT unique_user_org UNIQUE (user_id, org_id)
);

CREATE INDEX idx_user_org_user ON core.user_organizations(user_id);
CREATE INDEX idx_user_org_org ON core.user_organizations(org_id);
CREATE INDEX idx_user_org_status ON core.user_organizations(status);

-- Provisioning models per module
CREATE TABLE core.provisioning_models (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  module_id TEXT NOT NULL UNIQUE,
  
  model_type TEXT NOT NULL CHECK (model_type IN (
    'org_hierarchy',    -- LeaderForge: Company->Team->User
    'direct_user',      -- Brilliant School: Direct to users
    'delegated_admin'   -- Wealth: Admin manages users
  )),
  
  config JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Entitlement definitions
CREATE TABLE core.entitlements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT UNIQUE NOT NULL,
  display_name TEXT NOT NULL,
  description TEXT,
  module_id TEXT NOT NULL,
  
  -- What this entitlement grants
  features JSONB DEFAULT '{}',
  limits JSONB DEFAULT '{}', -- e.g., {"max_videos": 100}
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Organization entitlements (purchased/allocated)
CREATE TABLE core.org_entitlements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID NOT NULL REFERENCES core.organizations(id),
  entitlement_id UUID NOT NULL REFERENCES core.entitlements(id),
  
  -- Allocation
  quantity INTEGER DEFAULT 1, -- Number of seats/licenses
  allocated INTEGER DEFAULT 0, -- How many are assigned
  
  -- Validity
  granted_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  
  -- Provisioning
  granted_by UUID REFERENCES core.users(id),
  purchase_order TEXT,
  
  CONSTRAINT check_allocation CHECK (allocated <= quantity)
);

-- User entitlements (licenses)
CREATE TABLE core.user_entitlements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES core.users(id) ON DELETE CASCADE,
  entitlement_id UUID NOT NULL REFERENCES core.entitlements(id),
  org_entitlement_id UUID REFERENCES core.org_entitlements(id), -- Link to org allocation
  
  -- Validity
  granted_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  
  -- Tracking
  granted_by UUID REFERENCES core.users(id),
  grant_reason TEXT,
  metadata JSONB DEFAULT '{}',
  
  -- Constraints
  CONSTRAINT unique_active_entitlement UNIQUE (user_id, entitlement_id)
    WHERE revoked_at IS NULL
);

CREATE INDEX idx_user_entitlements_active ON core.user_entitlements(user_id)
  WHERE revoked_at IS NULL AND (expires_at IS NULL OR expires_at > NOW());

-- Module access rules
CREATE TABLE core.module_access_policies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  module_id TEXT NOT NULL,
  required_entitlements TEXT[] NOT NULL,
  access_mode TEXT CHECK (access_mode IN ('any', 'all')) DEFAULT 'any',
  
  CONSTRAINT unique_module_policy UNIQUE (module_id)
);

-- Email validation for provisioning
CREATE TABLE core.email_validations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL,
  token TEXT UNIQUE NOT NULL DEFAULT encode(gen_random_bytes(32), 'hex'),
  
  -- Purpose
  validation_type TEXT NOT NULL CHECK (validation_type IN (
    'user_invite',
    'org_invite',
    'email_change',
    'magic_link'
  )),
  
  -- Related entities
  user_id UUID REFERENCES core.users(id),
  org_id UUID REFERENCES core.organizations(id),
  metadata JSONB DEFAULT '{}',
  
  -- Status
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '24 hours',
  validated_at TIMESTAMPTZ,
  
  -- Security
  attempts INTEGER DEFAULT 0,
  ip_address INET,
  
  CONSTRAINT max_attempts CHECK (attempts <= 5)
);

CREATE INDEX idx_email_validation_token ON core.email_validations(token);
CREATE INDEX idx_email_validation_email ON core.email_validations(email);
```

## üí¨ Conversation & Agent Tables

### Event-Sourced Conversations
```sql
-- Conversation events (append-only)
CREATE TABLE core.conversation_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL,
  user_id UUID NOT NULL REFERENCES core.users(id),
  
  -- Event details
  event_type TEXT NOT NULL CHECK (event_type IN (
    'message_sent', 'message_received', 'agent_switched',
    'context_changed', 'action_performed', 'error_occurred'
  )),
  
  -- Actor (user or agent)
  actor_type TEXT NOT NULL CHECK (actor_type IN ('user', 'agent')),
  actor_id TEXT NOT NULL, -- agent_id or user_id
  
  -- Event data
  payload JSONB NOT NULL,
  module_context TEXT NOT NULL,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  sequence_number BIGSERIAL,
  
  -- Indexes for efficient queries
  CONSTRAINT unique_sequence UNIQUE (conversation_id, sequence_number)
);

CREATE INDEX idx_conversation_events_conv ON core.conversation_events(conversation_id);
CREATE INDEX idx_conversation_events_user ON core.conversation_events(user_id);
CREATE INDEX idx_conversation_events_created ON core.conversation_events(created_at);

-- Conversation metadata (mutable)
CREATE TABLE core.conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES core.users(id),
  
  -- State
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'archived', 'deleted')),
  last_message_at TIMESTAMPTZ,
  message_count INTEGER DEFAULT 0,
  
  -- Context
  module_context TEXT NOT NULL,
  active_agent_id TEXT,
  
  -- Metadata
  title TEXT, -- Auto-generated or user-defined
  tags TEXT[],
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Materialized view for conversation summaries
CREATE MATERIALIZED VIEW core.conversation_summaries AS
SELECT
  c.id,
  c.user_id,
  c.module_context,
  c.title,
  c.last_message_at,
  c.message_count,
  
  -- Recent messages
  (
    SELECT jsonb_agg(
      jsonb_build_object(
        'content', payload->>'content',
        'actor_type', actor_type,
        'created_at', created_at
      ) ORDER BY sequence_number DESC
    )
    FROM core.conversation_events ce
    WHERE ce.conversation_id = c.id
      AND ce.event_type = 'message_sent'
    LIMIT 5
  ) as recent_messages
  
FROM core.conversations c
WHERE c.status = 'active';

CREATE INDEX idx_conversation_summaries_user ON core.conversation_summaries(user_id);
```

## üìö Content Module Tables

### Module-Specific Content
```sql
-- Content library
CREATE TABLE modules_content.content (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Basic info
  title TEXT NOT NULL,
  description TEXT,
  content_type TEXT CHECK (content_type IN ('video', 'audio', 'document', 'course')),
  
  -- Files
  video_url TEXT,
  thumbnail_url TEXT,
  transcript_url TEXT,
  
  -- Metadata
  duration_seconds INTEGER,
  difficulty_level TEXT CHECK (difficulty_level IN ('beginner', 'intermediate', 'advanced')),
  
  -- Module assignment
  available_modules TEXT[] NOT NULL,
  categories JSONB DEFAULT '{}', -- {"movement": ["leadership", "prayer"]}
  tags TEXT[],
  
  -- Search optimization
  search_vector tsvector,
  embedding vector(1536), -- For semantic search
  
  -- Publishing
  published_at TIMESTAMPTZ,
  published_by UUID REFERENCES core.users(id),
  
  -- Metadata
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Full-text search
  CONSTRAINT content_search_vector_update 
    CHECK (search_vector = to_tsvector('english', coalesce(title, '') || ' ' || coalesce(description, '')))
);

-- Indexes for performance
CREATE INDEX idx_content_modules ON modules_content.content USING GIN(available_modules);
CREATE INDEX idx_content_search ON modules_content.content USING GIN(search_vector);
CREATE INDEX idx_content_embedding ON modules_content.content USING ivfflat(embedding vector_cosine_ops);
CREATE INDEX idx_content_published ON modules_content.content(published_at) WHERE published_at IS NOT NULL;

-- User progress tracking
CREATE TABLE modules_content.user_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES core.users(id),
  content_id UUID NOT NULL REFERENCES modules_content.content(id),
  
  -- Progress tracking
  module_context TEXT NOT NULL,
  progress_percentage INTEGER DEFAULT 0 CHECK (progress_percentage BETWEEN 0 AND 100),
  
  -- Engagement metrics
  watch_time_seconds INTEGER DEFAULT 0,
  last_position_seconds INTEGER DEFAULT 0,
  completion_count INTEGER DEFAULT 0,
  
  -- Timestamps
  started_at TIMESTAMPTZ DEFAULT NOW(),
  last_viewed_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  
  -- Ensure one progress per user/content/module
  CONSTRAINT unique_user_content_module UNIQUE (user_id, content_id, module_context)
);

CREATE INDEX idx_user_progress_user ON modules_content.user_progress(user_id);
CREATE INDEX idx_user_progress_completed ON modules_content.user_progress(completed_at) WHERE completed_at IS NOT NULL;
```

## üíé MLM Module Tables

### Commission Tracking
```sql
-- MLM hierarchy
CREATE TABLE modules_mlm.genealogy (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES core.users(id),
  sponsor_id UUID REFERENCES core.users(id),
  
  -- Placement in binary/unilevel tree
  placement_id UUID REFERENCES core.users(id),
  position TEXT CHECK (position IN ('left', 'right', 'auto')),
  
  -- Levels for quick queries
  level INTEGER NOT NULL DEFAULT 0,
  path TEXT[], -- Array of user_ids from top to this user
  
  -- Status
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'terminated')),
  
  -- Metadata
  enrolled_at TIMESTAMPTZ DEFAULT NOW(),
  activated_at TIMESTAMPTZ,
  
  -- Ensure tree integrity
  CONSTRAINT no_self_sponsor CHECK (user_id != sponsor_id),
  CONSTRAINT unique_user_position UNIQUE (user_id)
);

CREATE INDEX idx_genealogy_sponsor ON modules_mlm.genealogy(sponsor_id);
CREATE INDEX idx_genealogy_path ON modules_mlm.genealogy USING GIN(path);
CREATE INDEX idx_genealogy_level ON modules_mlm.genealogy(level);

-- Commission calculations
CREATE TABLE modules_mlm.commissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES core.users(id),
  
  -- Period
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,
  
  -- Amounts
  personal_volume DECIMAL(10,2) DEFAULT 0,
  group_volume DECIMAL(10,2) DEFAULT 0,
  commission_amount DECIMAL(10,2) DEFAULT 0,
  
  -- Details
  commission_details JSONB DEFAULT '{}', -- Breakdown by type
  rank_achieved TEXT,
  
  -- Status
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'paid', 'adjusted')),
  
  -- Processing
  calculated_at TIMESTAMPTZ DEFAULT NOW(),
  approved_at TIMESTAMPTZ,
  paid_at TIMESTAMPTZ,
  
  -- Ensure one record per user per period
  CONSTRAINT unique_user_period UNIQUE (user_id, period_start, period_end)
);

CREATE INDEX idx_commissions_period ON modules_mlm.commissions(period_start, period_end);
CREATE INDEX idx_commissions_status ON modules_mlm.commissions(status);
```

## üìì Journal Module Tables

### Secure Local Storage
```sql
-- Journal entries with encryption support
CREATE TABLE modules_journal.entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES core.users(id),
  
  -- Content (may be encrypted)
  content TEXT, -- Encrypted on client, stored encrypted
  content_encrypted BOOLEAN DEFAULT false,
  
  -- Voice notes
  voice_url TEXT,
  voice_transcript TEXT,
  
  -- Organization
  module_context TEXT NOT NULL,
  tags TEXT[],
  mood TEXT,
  
  -- Sync status
  device_id TEXT,
  sync_version INTEGER DEFAULT 1,
  sync_status TEXT DEFAULT 'synced' CHECK (sync_status IN ('synced', 'pending', 'conflict')),
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ,
  
  -- Version control for conflict resolution
  version_vector JSONB DEFAULT '{}' -- CRDT-style versioning
);

CREATE INDEX idx_journal_user ON modules_journal.entries(user_id);
CREATE INDEX idx_journal_sync ON modules_journal.entries(sync_status) WHERE sync_status != 'synced';
CREATE INDEX idx_journal_deleted ON modules_journal.entries(deleted_at) WHERE deleted_at IS NULL;

-- Sync conflict resolution
CREATE TABLE modules_journal.sync_conflicts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entry_id UUID NOT NULL REFERENCES modules_journal.entries(id),
  
  -- Conflicting versions
  local_version JSONB NOT NULL,
  remote_version JSONB NOT NULL,
  
  -- Resolution
  resolution_strategy TEXT CHECK (resolution_strategy IN ('local', 'remote', 'merge', 'manual')),
  resolved_version JSONB,
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES core.users(id),
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

## üîç Analytics Tables

### Learning Analytics
```sql
-- Event tracking for analytics
CREATE TABLE analytics.learning_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  
  -- Event details
  event_type TEXT NOT NULL,
  module_context TEXT NOT NULL,
  
  -- What happened
  content_id UUID,
  duration_seconds INTEGER,
  score DECIMAL(5,2),
  
  -- Context
  device_type TEXT,
  browser TEXT,
  ip_address INET,
  
  -- Payload for flexibility
  properties JSONB DEFAULT '{}',
  
  -- Time
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Partitioning by month for performance
  CONSTRAINT learning_events_partition CHECK (
    created_at >= DATE_TRUNC('month', created_at) AND
    created_at < DATE_TRUNC('month', created_at) + INTERVAL '1 month'
  )
) PARTITION BY RANGE (created_at);

-- Create partitions for the next 12 months
DO $$
BEGIN
  FOR i IN 0..11 LOOP
    EXECUTE format(
      'CREATE TABLE analytics.learning_events_%s PARTITION OF analytics.learning_events
       FOR VALUES FROM (%L) TO (%L)',
      to_char(CURRENT_DATE + (i || ' months')::interval, 'YYYY_MM'),
      DATE_TRUNC('month', CURRENT_DATE + (i || ' months')::interval),
      DATE_TRUNC('month', CURRENT_DATE + ((i+1) || ' months')::interval)
    );
  END LOOP;
END $$;

-- Aggregated metrics (refreshed hourly)
CREATE MATERIALIZED VIEW analytics.user_metrics AS
SELECT
  user_id,
  module_context,
  DATE_TRUNC('day', created_at) as date,
  
  -- Engagement metrics
  COUNT(DISTINCT content_id) as unique_content_viewed,
  SUM(CASE WHEN event_type = 'content_completed' THEN 1 ELSE 0 END) as completions,
  SUM(duration_seconds) as total_watch_time,
  AVG(score) as average_score
  
FROM analytics.learning_events
WHERE created_at > CURRENT_DATE - INTERVAL '90 days'
GROUP BY user_id, module_context, DATE_TRUNC('day', created_at);

CREATE INDEX idx_user_metrics_lookup ON analytics.user_metrics(user_id, module_context, date);
```

## üìù Audit & Compliance

### Immutable Audit Log
```sql
-- Audit all changes
CREATE TABLE audit.audit_log (
  id BIGSERIAL PRIMARY KEY,
  
  -- Who
  user_id UUID,
  tenant_id UUID,
  
  -- What
  action TEXT NOT NULL,
  table_name TEXT NOT NULL,
  record_id UUID,
  
  -- Changes
  old_values JSONB,
  new_values JSONB,
  
  -- Context
  module_context TEXT,
  ip_address INET,
  user_agent TEXT,
  request_id UUID,
  
  -- When
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Partitioned by month for performance
CREATE INDEX idx_audit_created ON audit.audit_log(created_at);
CREATE INDEX idx_audit_user ON audit.audit_log(user_id);
CREATE INDEX idx_audit_record ON audit.audit_log(table_name, record_id);

-- Trigger function for automatic auditing
CREATE OR REPLACE FUNCTION audit.create_audit_trigger(target_table text)
RETURNS void AS $$
BEGIN
  EXECUTE format('
    CREATE TRIGGER audit_trigger
    AFTER INSERT OR UPDATE OR DELETE ON %I
    FOR EACH ROW EXECUTE FUNCTION audit.log_change();
  ', target_table);
END;
$$ LANGUAGE plpgsql;
```

## üîß Database Functions & Procedures

### User Entitlement Check
```sql
CREATE OR REPLACE FUNCTION core.user_has_entitlement(
  p_user_id UUID,
  p_entitlement_name TEXT
) RETURNS BOOLEAN AS $$
DECLARE
  v_has_entitlement BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1
    FROM core.user_entitlements ue
    JOIN core.entitlements e ON e.id = ue.entitlement_id
    WHERE ue.user_id = p_user_id
      AND e.name = p_entitlement_name
      AND ue.revoked_at IS NULL
      AND (ue.expires_at IS NULL OR ue.expires_at > NOW())
  ) INTO v_has_entitlement;
  
  RETURN v_has_entitlement;
END;
$$ LANGUAGE plpgsql STABLE;

-- Module access check
CREATE OR REPLACE FUNCTION core.user_can_access_module(
  p_user_id UUID,
  p_module_id TEXT
) RETURNS BOOLEAN AS $$
DECLARE
  v_required_entitlements TEXT[];
  v_access_mode TEXT;
BEGIN
  -- Get module requirements
  SELECT required_entitlements, access_mode
  INTO v_required_entitlements, v_access_mode
  FROM core.module_access_policies
  WHERE module_id = p_module_id;
  
  -- No policy means open access
  IF NOT FOUND THEN
    RETURN true;
  END IF;
  
  -- Check entitlements based on mode
  IF v_access_mode = 'any' THEN
    -- User needs at least one entitlement
    RETURN EXISTS (
      SELECT 1
      FROM unnest(v_required_entitlements) AS required
      WHERE core.user_has_entitlement(p_user_id, required)
    );
  ELSE
    -- User needs all entitlements
    RETURN NOT EXISTS (
      SELECT 1
      FROM unnest(v_required_entitlements) AS required
      WHERE NOT core.user_has_entitlement(p_user_id, required)
    );
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;
```

### Content Search
```sql
-- Hybrid search combining full-text and vector similarity
CREATE OR REPLACE FUNCTION modules_content.search_content(
  p_query TEXT,
  p_module TEXT,
  p_embedding vector(1536) DEFAULT NULL,
  p_limit INT DEFAULT 20
) RETURNS TABLE (
  id UUID,
  title TEXT,
  description TEXT,
  score FLOAT
) AS $$
BEGIN
  RETURN QUERY
  WITH text_search AS (
    SELECT
      c.id,
      c.title,
      c.description,
      ts_rank(c.search_vector, websearch_to_tsquery('english', p_query)) as text_score
    FROM modules_content.content c
    WHERE p_module = ANY(c.available_modules)
      AND c.published_at IS NOT NULL
      AND c.search_vector @@ websearch_to_tsquery('english', p_query)
  ),
  vector_search AS (
    SELECT
      c.id,
      c.title,
      c.description,
      1 - (c.embedding <=> p_embedding) as vector_score
    FROM modules_content.content c
    WHERE p_module = ANY(c.available_modules)
      AND c.published_at IS NOT NULL
      AND p_embedding IS NOT NULL
    ORDER BY c.embedding <=> p_embedding
    LIMIT p_limit
  )
  SELECT DISTINCT
    COALESCE(t.id, v.id) as id,
    COALESCE(t.title, v.title) as title,
    COALESCE(t.description, v.description) as description,
    COALESCE(t.text_score, 0) * 0.5 + COALESCE(v.vector_score, 0) * 0.5 as score
  FROM text_search t
  FULL OUTER JOIN vector_search v ON t.id = v.id
  ORDER BY score DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

## üö® Migration Best Practices

### Safe Migration Pattern
```sql
-- ALWAYS use transactions for schema changes
BEGIN;

-- Add new column with default
ALTER TABLE core.users 
ADD COLUMN IF NOT EXISTS preferences JSONB DEFAULT '{}';

-- Backfill data if needed
UPDATE core.users 
SET preferences = jsonb_build_object(
  'theme', 'light',
  'language', 'en'
)
WHERE preferences = '{}';

-- Add constraints after backfill
ALTER TABLE core.users
ADD CONSTRAINT valid_preferences 
CHECK (
  preferences ? 'theme' AND 
  preferences ? 'language'
);

COMMIT;

-- ALWAYS create rollback scripts
-- rollback/001_remove_preferences.sql
BEGIN;
ALTER TABLE core.users DROP COLUMN IF EXISTS preferences;
COMMIT;
```

## üìù Database Checklist

- [ ] Table belongs to correct schema
- [ ] RLS policies defined
- [ ] Indexes for common queries
- [ ] Foreign key constraints
- [ ] Check constraints for data integrity
- [ ] Audit triggers attached
- [ ] Comments on tables and columns
- [ ] Migration includes rollback
- [ ] Performance tested with EXPLAIN
- [ ] Partitioning for large tables